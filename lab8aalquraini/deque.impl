// IMPLEMENTATIONS

namespace csen79_lab8
{
    
    //CONSTRUCTOR
    template <class Item>
    deque<Item>::deque (size_type init_bp_array_size, size_type init_block_size) :
        bp_array_size{init_bp_array_size}, block_size{init_block_size}
    {
        // Create an an array of block pointers and assign its address to "block_pointers"
        block_pointers = new value_type* [bp_array_size];
        
        // Assign nullptr to all the entries of the array of block pointers
        for (size_type index = 0; index < bp_array_size; ++index)
        {
            block_pointers[index] = nullptr;
        }
        
        // Set block_pointers_end to point to the end of the array
        block_pointers_end = block_pointers + (bp_array_size - 1);
        
        first_bp = last_bp = nullptr;
        front_ptr = back_ptr = nullptr;
    }
    
    //COPY CONSTRUCTOR
    template <class Item>
    deque<Item>::deque (const deque<Item>& source) {
        
        first_bp = last_bp = nullptr;
        front_ptr = back_ptr = nullptr;
        block_pointers = block_pointers_end = nullptr;
        
        // Use the assignment operator
        // (must have been already implemented, you cannot rely on the compiler)
        *this = source;
    }
    
    
    // ASSIGNMENT OPERATOR
    template <class Item>
    void deque<Item>::operator=(const deque<Item>& source) {
        
        // Invoke the clear() function
        clear();
        
        // Delete the array of block pointers
        delete [] block_pointers;
        block_pointers = nullptr;
        block_pointers_end = nullptr;
        
        // Copy the size variables from "source" object
        bp_array_size = source.bp_array_size;
        block_size = source.block_size;
        
        // Create a new array of block pointers
		block_pointers = new value_type *[bp_array_size];
        
        
        // Copy the data blocks of "source" object
        for (size_type bp_array_index = 0; bp_array_index < source.bp_array_size; ++bp_array_index)
        {
            // If an entry of source.block_pointers is nullptr, that entry should be nullptr in this object as well
            if (source.block_pointers[bp_array_index] == nullptr)
            {
                block_pointers[bp_array_index] = nullptr;
            }
            else
            {
                //If this is the first_bp of source, then set the first_bp of this deque
				if(source.block_pointers[bp_array_index] == source.first_bp){
                    first_bp = source.first_bp;
                }
                
                //If this is the last_bp of source, then set the last_bp of this deque
				if()
                
                // Create a data block
                block_pointers[bp_array_index] = new value_type [block_size];
                
                // Copy the elements, and set "front_ptr" and "back_ptr" if appropriate
                for (size_type block_item_index = 0; block_item_index < block_size; ++block_item_index)
                {
					// STUDENT WORK...
                }
            }
        }
        
    }
    
    
    //DESTRUCTOR
    template <class Item>
    deque<Item>::~deque () {
        
        // Clear the data blocks
		// STUDENT WORK...
        
        // Clear the array of block pointers
		// STUDENT WORK...
        
        first_bp = last_bp = block_pointers_end = block_pointers = nullptr;
        front_ptr = back_ptr = nullptr;
    }
    
    
    template <class Item>
    void deque<Item>::clear () {
        
        // Clear the data blocks
		// STUDENT WORK...
        
        first_bp = last_bp = nullptr;
        front_ptr = back_ptr = nullptr;
        
        // Note: The array of block pointers should not be deleted;
        //       However, all of its entries are nullptr because all the
        //       data blocks have been deleted.
    }
    
    
    
    template <class Item>
    void deque<Item>::reserve()
    {
        Debug("Reserving new ..." << std::endl);
        
        // The new array of block pointers includes 20 more entries
        // This results in increasing the size by 20 x BLOCK_SIZE
        size_type newSize = bp_array_size + 20;
        
        // Create a new array of block pointers
        value_type** new_block_pointers = new value_type* [newSize];
        
        // Assign nullptr to all the entries of the array of block pointers
        for (size_type index = 0; index < newSize; ++index)
        {
            new_block_pointers[index] = nullptr;
        }
        
        // Find the location of "first_bp" in the new array of block pointers
        // The offset enables us to copy the not-nullptr elements of the existing array to the middle of the new array
        size_type offsett_first_bp = first_bp - block_pointers;
        size_type offsett_last_bp = last_bp - block_pointers;
        
        // Copy the not-nullptr elements of the array of block pointers to the new array, starting at the computer offset
        std::copy(first_bp, last_bp + 1, new_block_pointers + 10 + offsett_first_bp);
        
        
        Debug("Testing value - offsett_first_bp = " << offsett_first_bp << std::endl);
        Debug("Testing value - offsett_last_bp = " << offsett_last_bp << std::endl);
        Debug("Testing value - first_bp = " << *first_bp << std::endl);
        Debug("Testing value - last_bp = " << *last_bp << std::endl);
        
        // Delete the existing array of block pointers
        delete [] block_pointers;
        
        // Set the pointers
        block_pointers = new_block_pointers;
        bp_array_size = newSize;
        block_pointers_end = block_pointers + bp_array_size - 1;
        first_bp = block_pointers + offsett_first_bp + 10;
        last_bp = block_pointers + offsett_last_bp + 10;
        
        Debug("Print at the end of the reserve function..." << std::endl);
        
        Debug("Testing value - first_bp = " << *first_bp << std::endl);
        Debug("Testing value - last_bp = " << *last_bp << std::endl);
    }
    
    
    template <class Item>
    void deque<Item>::push_front(const value_type& entry)
    {
        // Only the array of block pointers exists (and no data block exists)
        if (first_bp == nullptr)
        {
            assert(bp_array_size > 1);
            size_t bp_mid = floor(bp_array_size/2); // Get the mid point of the array of block pointers
            
            // Both last_bp and first_bp point to the same
            // location of the array of block pointers
            last_bp = first_bp = block_pointers + bp_mid - 1;
            
			// STUDENT WORK
        }
        
        // There is at least one empty slot before the entry that front_ptr points to (in the same data block)
        else if (front_ptr != *first_bp)
        {
			// STUDENT WORK
        }
        
        // Data block has no room left before front_ptr; however, the array of block pointers has at least one available slot before first_bp to allocate a new data block
        else if ((*first_bp == front_ptr) && (first_bp != block_pointers))
        {
			// STUDENT WORK
        }
        
        // Data block has no room left before front_ptr; and the array of block pointers has no available slot before first_bp
        else if ((*first_bp == front_ptr) && (first_bp == block_pointers))
        {
			// STUDENT WORK
        }
    }
    
    
    template <class Item>
    void deque<Item>::push_back(const value_type& entry)
    {
        // Only the array of block pointers exists (and no data block exists)
        if (last_bp == nullptr)
        {
            assert(bp_array_size > 1);
            size_t bp_mid = floor(bp_array_size/2); // Get the mid point of the array of block pointers
            
            last_bp = first_bp = block_pointers + bp_mid  - 1;
			// STUDENT WORK
        }
        
        // There is at least one empty slot after the entry that back_ptr points to (in the same data block)
        else if (back_ptr != ((*last_bp) + (block_size - 1)))
        {
			// STUDENT WORK
        }
        
        // Data block has no room left after back_ptr; however, the array of block pointers has at least one available slot below last_bp to allocate a new data block
        else if ((back_ptr == ((*last_bp) + (block_size - 1))) && (last_bp != block_pointers_end))
        {
			// STUDENT WORK
        }
        
        // Data block has no room left after back_ptr; and the array of block pointers has no available slot after last_bp
        else if ((back_ptr == ((*last_bp) + (block_size - 1))) && (last_bp == block_pointers_end))
        {
			// STUDENT WORK
        }
    }
    
    
    template <class Item>
    void deque<Item>::pop_front()
    {
        assert(!isEmpty());
        
        // This is the only entry in the deque; remove it and delete the data block
        if (back_ptr == front_ptr)
        {
			// STUDENT WORK
        }
        // This is the last entry of the data block; move to the next block
        else if (front_ptr == ((*first_bp) + block_size - 1))
        {
			// STUDENT WORK
        }
        // Simply move the pointer
        else
        {
			// STUDENT WORK
        }
    }
    
    
    template <class Item>
    void deque<Item>::pop_back()
    {
        assert(!isEmpty());
        
        if (back_ptr == front_ptr)
        {
            clear( );
        }
        else if (back_ptr == *last_bp)
        {
			// STUDENT WORK
        }
        else
        {
            --back_ptr;
        }
    }
    
    template <class Item>
    bool deque<Item>::isEmpty() const
    {
        if (front_ptr == nullptr)
            return true;
        
        return false;
    }
    
    template <class Item>
    typename deque<Item>::value_type deque<Item>::back() const
    {
        assert(!isEmpty());
        return *back_ptr;
    }
    
    template <class Item>
    typename deque<Item>::value_type deque<Item>::front() const
    {
        assert(!isEmpty());
        return *front_ptr;
    }
    
    // Constructs an itertor which points to the first element of the deque
    template <class Item>
    typename deque<Item>::iterator deque<Item>::begin()
    {
        value_type* tmp_cursor = nullptr;
        value_type* tmp_current_boundary = nullptr;
        value_type** tmp_current_block_pointer = nullptr;
        
        if (front_ptr != nullptr)
        {
            tmp_cursor = front_ptr;
            tmp_current_block_pointer = first_bp;
            tmp_current_boundary = (*first_bp) + (block_size - 1);
        }
        
        return iterator(block_pointers, block_pointers_end, first_bp, last_bp,
                        front_ptr, back_ptr,
                        bp_array_size, block_size,
                        tmp_cursor, tmp_current_boundary, tmp_current_block_pointer);
    }
    
    // Constructs an itertor which points to the past the last element of the deque
    template <class Item>
    typename deque<Item>::iterator deque<Item>::end()
    {
        value_type* tmp_cursor = nullptr;
        value_type* tmp_current_boundary = nullptr;
        value_type** tmp_current_block_pointer = nullptr;
        
        return iterator(block_pointers, block_pointers_end, first_bp, last_bp,
                        front_ptr, back_ptr,
                        bp_array_size, block_size,
                        tmp_cursor, tmp_current_boundary, tmp_current_block_pointer);
    }
    
}
