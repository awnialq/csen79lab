// CSEN, SCU
// Implementation for deque_iterator
namespace csen79_lab8
{
    template <class Item>
	bool deque_iterator<Item>::operator ==(const deque_iterator<Item> &other) const
	{
		//iterators are equal when they refer to the same deque and have the same block position
		return (block_pointers == other.block_pointers)
			&& (block_pointers_end == other.block_pointers_end)
			&& (first_bp == other.first_bp)
			&& (last_bp == other.last_bp)
			&& (front_ptr == other.front_ptr)
			&& (back_ptr == other.back_ptr)
			&& (bp_array_size == other.bp_array_size)
			&& (block_size == other.block_size)
			&& (cursor == other.cursor)
			&& (current_boundary == other.current_boundary)
			&& (current_block_pointer == other.current_block_pointer);
	}

    template <class Item>
	deque_iterator<Item>& deque_iterator<Item>::operator ++( ) // Prefix ++
	{
		// The cursor cannot move forward, simply return the iterator
		if (cursor == nullptr)
			return *this;
		
		// There is no item after the current item. Set the variables. Return the itertor.
		if (cursor == back_ptr)
		{
			cursor = nullptr;
			current_boundary = nullptr;
			current_block_pointer = nullptr;
			return *this;
		}
		
		// Move to the next data block
		if (cursor == current_boundary)
		{
			++current_block_pointer;
			cursor = *current_block_pointer;
			current_boundary = (*current_block_pointer) + (block_size - 1);
		}
		// Move forward
		else
		{
			++cursor;
		}
		
		return *this;
	}

    template <class Item>
	deque_iterator<Item> deque_iterator<Item>::operator ++(int) // Postfix ++
	{
		deque_iterator original;
		original = *this;
		
		// The cursor cannot move forward, simply return the iterator
		if (cursor == nullptr)
			return original;
		
		// There is no item after the current item. Set the variables. Return the itertor.
		if (cursor == back_ptr)
		{
			cursor = nullptr;
			current_boundary = nullptr;
			current_block_pointer = nullptr;
			return original;
		}
		
		// Move to the next data block
		if (cursor == current_boundary)
		{
			++current_block_pointer;
			cursor = *current_block_pointer;
			current_boundary = (*current_block_pointer) + (block_size - 1);
		}
		// Move forward
		else
		{
			++cursor;
		}
		
		return original;
	}
}
